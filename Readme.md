## Algoritmos üöÄüöÄ
<hr />

Este reposit√≥rio cont√©m implementa√ß√µes de uma variedade de algoritmos cl√°ssicos e comuns. Cada algoritmo √© acompanhado de uma breve descri√ß√£o e exemplos de uso, quando aplic√°vel.

### Algoritmos de Grafos üî•
<hr />

* *Prim's Algorithm*: Um algoritmo de √°rvore de expans√£o m√≠nima que encontra o subconjunto de arestas que forma uma √°rvore que inclui todos os v√©rtices, onde o peso total da √°rvore √© minimizado.

* *Kruskal's Algorithm*: Um algoritmo de √°rvore de expans√£o m√≠nima que encontra um subconjunto m√≠nimo de arestas que conecta todos os v√©rtices de um grafo ponderado.

* *Dijkstra's Algorithm*: Um algoritmo para encontrar os caminhos mais curtos entre os n√≥s em um grafo ponderado, que pode representar, por exemplo, dist√¢ncias rodovi√°rias entre cidades.

* *Bellman-Ford Algorithm*: Um algoritmo de caminho mais curto que encontra o caminho mais curto em um grafo ponderado com arestas de peso negativo.

### Algoritmos de Busca üî•
<hr />

* *A Algorithm\**: Um algoritmo de busca heur√≠stica que encontra o caminho mais curto entre um n√≥ de origem e um n√≥ de destino.

* *Binary Search Algorithm*: Um algoritmo eficiente para encontrar o valor desejado em uma lista ordenada.

* *Linear Search Algorithm*: Um algoritmo simples para encontrar um valor em uma lista, percorrendo-a sequencialmente.

### Algoritmos de Ordena√ß√£o üî•
<hr />

* *Tree Sort Algorithm*: Um algoritmo de ordena√ß√£o que constr√≥i uma √°rvore bin√°ria de busca a partir dos elementos a serem classificados.

* *Tim Sort Algorithm*: Um algoritmo de ordena√ß√£o h√≠brido derivado do merge sort e insertion sort, utilizado como algoritmo padr√£o de ordena√ß√£o em Python.

* *Shell Sort Algorithm*: Um algoritmo de ordena√ß√£o eficiente, uma generaliza√ß√£o do insertion sort que permite a troca de itens distantes.

* *Radix Sort Algorithm*: Um algoritmo de ordena√ß√£o n√£o comparativo que classifica inteiros processando d√≠gitos individuais.

* *Cube Sort Algorithm*: Um algoritmo de ordena√ß√£o que divide a lista em cubos e depois ordena os cubos.

* *Counting Sort Algorithm*: Um algoritmo de ordena√ß√£o eficiente, especialmente √∫til quando a faixa de valores a serem classificados √© relativamente pequena.

* *Bucket Sort Algorithm*: Um algoritmo de ordena√ß√£o que funciona distribuindo os elementos de entrada em um n√∫mero finito de "buckets" e depois ordenando cada bucket individualmente.

* *Heap Sort Algorithm*: Um algoritmo de ordena√ß√£o baseado em estrutura de dados heap.

* *Selection Sort Algorithm*: Um algoritmo de ordena√ß√£o simples que encontra o menor elemento da lista e o coloca na posi√ß√£o correta.

* *Insertion Sort Algorithm*: Um algoritmo de ordena√ß√£o eficiente que constr√≥i a lista ordenada um elemento de cada vez.

* *Bubble Sort Algorithm*: Um algoritmo de ordena√ß√£o simples que compara cada par de elementos adjacentes e os troca se estiverem na ordem errada.

* *Quick Sort Algorithm*: Um algoritmo de ordena√ß√£o eficiente e flex√≠vel que utiliza a estrat√©gia de divis√£o e conquista.

* *Merge Sort Algorithm*: Um algoritmo de ordena√ß√£o que divide a lista em sublistas, ordena essas sublistas e depois as mescla.

### Algoritmos de Problemas Espec√≠ficos üî•
<hr />

* *N-Queen Problem Algorithm*: Um algoritmo que resolve o problema de colocar N rainhas em um tabuleiro de xadrez de tal forma que nenhuma rainha possa atacar outra.

* *Maze Solving Problem Algorithm*: Um algoritmo que encontra um caminho ou solu√ß√£o para um labirinto.

### Algoritmos de Cache üî•
<hr />

* *MRU Cache Algorithm*: Um algoritmo de substitui√ß√£o de cache que remove do cache o elemento que foi acessado mais recentemente.

* *LFU Cache Algorithm*: Um algoritmo de substitui√ß√£o de cache que remove do cache o elemento menos frequentemente usado.

* *LRU Cache Algorithm*: Um algoritmo de substitui√ß√£o de cache que remove do cache o elemento que foi menos recentemente usado.

### Outros Algoritmos üî•
<hr />

* *Knight Tour Algorithm*: Um algoritmo que resolve o problema do passeio do cavalo, que consiste em encontrar um caminho para o cavalo passar por todas as casas de um tabuleiro de xadrez exatamente uma vez.

* *Hamiltonian Path Algorithm*: Um algoritmo que resolve o problema de encontrar um caminho que visite cada v√©rtice de um grafo exatamente uma vez.

* *Ford Fulkerson Algorithm*: Um algoritmo para encontrar o fluxo m√°ximo em uma rede de fluxo.

### Algoritmos de Codifica√ß√£o üî•
<hr />

* *Huffman Algorithm*: Um algoritmo de compress√£o de dados que utiliza c√≥digos de tamanho vari√°vel para representar os s√≠mbolos na fonte de dados.

* *CRC32 Algorithm*: Um algoritmo de verifica√ß√£o de redund√¢ncia c√≠clica (CRC) que produz um valor de verifica√ß√£o de 32 bits para dados de entrada.
